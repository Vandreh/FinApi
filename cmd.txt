NodeJs:
FinApi:
https://app.rocketseat.com.br/node/primeiro-projeto-com-node-js/lesson/remover-conta


github dos colegas:
https://github.com/NehamaMandelbaum/FinAPI
https://github.com/colacobruno/node-desafio1



mkdir fundamentos_nodejs
cd fundamentos_nodejs
yarn init -y

yarn add express

node src/index.js


yarn add nodemon -D
yarn dev


yarn add uuid


https://insomnia.rest/download



















FunÃ§Ã£o splice deletando conta errada ao criar novamente a conta
Aula em: Primeiro projeto com Node.js â€º Primeiro projeto com Node.js â€º Remover conta

Percebi que ao tentar criar a conta novamente com o mesmo CPF e depois deletar, a funÃ§Ã£o splice estava removendo a posiÃ§Ã£o errada ao utilizar dessa forma:

costumers.splice(costumer, 1);

Resolvi a situaÃ§Ã£o buscando o index do costumer com findIndex, dessa forma:

const indexCostumer = costumers.findIndex(
costumerIndex => costumerIndex.cpf === costumer.cpf);

costumers.splice(indexCostumer, 1);

Agora a funÃ§Ã£o splice funciona corretamente
Luiz Fernando Martins Leite
04/05/21 Ã s 18:21

Nem tinha reparado nisso, Obrigado por postar Camila, funcionou certinho sua dica
Arthur G. Machado Raimundo
09/05/21 Ã s 17:46

Nao reparei tbm, eu pensei em fazer pelo filter, mas seu jeito ficou mais explicito.
Eduardo Bess
02/09/21 Ã s 06:13

Bem observado Camila! Apenas observo que, para rodar corretamente no cÃ³digo da aula da Dani, precisamos escrever "customer" e nÃ£o "costumer", para que a variÃ¡vel seja encontrada.
Bernardo Rosa Pinheiro
06/10/21 Ã s 15:53

Muito bom, ficou perfeito.
Elson Costa
03/02/22 Ã s 15:51

Havia reparado durante a aula que nÃ£o estava funcionando corretamente, mas nÃ£o havia conseguido responder sem a sua ajuda. Ob rigado.
Melhor Resposta
Bruno De Araujo Gomes
19/04/21 Ã s 22:35 | Editado em 16/03/2022

OlÃ¡ @Camila Queiroz,

VocÃª esta correta na video aula apresenta por se tratar do primeiro registro, Ã© passada aquela sensaÃ§Ã£o que funcionou perfeitamente, porÃ©m o splice sempre apaga a primeira posiÃ§Ã£o do array.

Olha como ficou o cÃ³digo

app.delete("/repositories/:id", (request, response) => {
  const { id } = request.params;

  const repositoryIndex = repositories.findIndex(repository => repository.id === id);

  if (repositoryIndex === -1) {
    return response.status(404).json({ error: 'Repository Not Found' });
  }

  repositories.splice(repositoryIndex, 1);

  return response.status(204).json();

});

Camila Queiroz
25/04/21 Ã s 23:40

Sim @Bruno De Araujo Gomes, fiz exatamente dessa forma.. funcionou tudo ok
Daizovitch
16/03/22 Ã s 05:33

@Camila Queiroz
TambÃ©m notei isso, resolvi utilizando indexOf
Todas as respostas

PÃ¡gina 1 de pÃ¡gina 1
Priscila Martins
24/04/21 Ã s 12:53 | Editado em 20/03/2022

Oi Camila. Eu percebi a mesma coisa.
Mas ao invÃ©s de fazer uma nova consulta para retornar o Ã­ndice eu usei a funÃ§Ã£o indexOf, ficando assim:

const { customer } = request;

customers.splice(customers.indexOf(customer),1);

Como eu nÃ£o conheÃ§o tanto o Javascript nÃ£o sei se pode haver algum problema em relaÃ§Ã£o Ã  performance em caso de arrays muito grandes, mas foi uma soluÃ§Ã£o que achei mais simples.
Camila Queiroz
25/04/21 Ã s 23:45

@Priscila Martins Muito bom, como jÃ¡ temos o objeto, o indexOf Ã© um recurso legal de usar nesse caso mesmo.. bem lembrado
Nuno Miranda
09/05/21 Ã s 00:10

eu deixei assim: customers.splice(customers.indexOf(customer,1),1);
nÃ£o sei se fica ambiguo, mas funcionou
LUIS MATHEUS BARBOSA DA SILVA SANTOS
26/06/21 Ã s 19:11

@Priscila Martins funcionou perfeitamente, mas porque ? kkk Eu tentei reproduzir fora do node e nÃ£o funcionou , sempre retorna -1 , porque aqui ele funciona ?
Ricardo Kanashiro
04/12/21 Ã s 14:19

Muito obrigado, foi um dos mÃ©todos mais simples que achei msm!
Noan Almeida
15/01/22 Ã s 20:57

Muito obrigado, foi a maneira mais enxuta e a que funcionou perfeitamente!
Bruno De Araujo Gomes
19/04/21 Ã s 22:35 | Editado em 16/03/2022

OlÃ¡ @Camila Queiroz,

VocÃª esta correta na video aula apresenta por se tratar do primeiro registro, Ã© passada aquela sensaÃ§Ã£o que funcionou perfeitamente, porÃ©m o splice sempre apaga a primeira posiÃ§Ã£o do array.

Olha como ficou o cÃ³digo

app.delete("/repositories/:id", (request, response) => {
  const { id } = request.params;

  const repositoryIndex = repositories.findIndex(repository => repository.id === id);

  if (repositoryIndex === -1) {
    return response.status(404).json({ error: 'Repository Not Found' });
  }

  repositories.splice(repositoryIndex, 1);

  return response.status(204).json();

});

Camila Queiroz
25/04/21 Ã s 23:40

Sim @Bruno De Araujo Gomes, fiz exatamente dessa forma.. funcionou tudo ok
Daizovitch
16/03/22 Ã s 05:33

@Camila Queiroz
TambÃ©m notei isso, resolvi utilizando indexOf
Roberto
25/04/21 Ã s 16:24 | Editado em 12/09/2021

O vÃ­deo estÃ¡ com os passo com falha, seguindo a idÃ©ia do @Bruno De Araujo Gomes, bateu na boa os testes.
TambÃ©m fiz o seguinte:

const balance = getBalance(customer.statement);
if (balance !== 0) {
return response.status(400).json({ erro: "To delete an account, it isn't have found"});
}

Pois para apagar uma conta em um banco, ela nao deve ter saldo.
Paulo Cesar Morais De Oliveira
27/10/21 Ã s 14:43 | Editado em 14/03/2022

A pergunta Ã©, pq o pessoal da RocketSeat nao arrumou ou fez uma observaÃ§Ã£o visto que vÃ¡rias pessoas viram o erro comentaram aqui, e os que estÃ£o chegando agora nesse ponto ficam passando trabalho de graÃ§a achando que fizeram algo errado!
Igor Piedade
21/10/21 Ã s 11:53 | Editado em 01/12/2021

TambÃ©m percebi o erro aos fazer os testes criando vÃ¡rios usuÃ¡rios e tentando deletar um usuÃ¡rio que estÃ¡ no meio da pilha, o que nÃ£o aconteceu. Obrigado pelas colaboraÃ§Ãµes.
Dillon Patrick
28/08/21 Ã s 16:47 | Editado em 12/09/2021

Criei mais uma condiÃ§Ã£o para o "delete": Se o saldo da conta for positivo, nÃ£o autorizar a exclusÃ£o. Se tiver algo errado eu aceito sugestÃµes

app.delete("/account", verifyIfExistingCPF, (request, response) => {
  const { customer } = request;
  const { cpf } = request.headers;

  const balance = getBalance(customer.statement);

  const customerIndex = customers.findIndex((customer) => customer.cpf === cpf);

  if (customerIndex < 0) {
    return response.status.json({ error: "Customer Not found" });
  }
  if (balance > 0) {
    return response
      .status(401)
      .json({
        error:
          "It is not possible to delete an account with a positive balance",
      });
  }

  customers.splice(customerIndex, 1);
  return response.status(200).send();
});

Luis Henrique De Jesus Lima
19/01/22 Ã s 13:24

Eu percebi o erro e vim procura nos comentÃ¡rios e o seu me ajudou, bom d+.
Gabriel Costa
04/11/21 Ã s 22:48

Na realidade o erro ocorre pois utiliza-se o customer checado no middleware pelo cpf enviado na header na hora do delete .
No middleware Ã© utilizado o mÃ©todo find, que retorna o primeiro resultado que encontra quando a condiÃ§Ã£o Ã© satisfeita. PorÃ©m, nÃ£o sei como conseguiram criar mais de um usuÃ¡rio com o mesmo cpf, visto que no metodo de criaÃ§Ã£o de usuÃ¡rios existe uma verificaÃ§Ã£o(a funÃ§Ã£o customerAlreadyExists) exatamente para nÃ£o permitir isso.
De qualquer forma o mais correto seria enviar o cpf na requisiÃ§ao(por query params, por ex) encontrar o index dele no array(com o indexOf como mencionaram) e daÃ­ usar o splice para esse Ã­ndice.
Daniel Ribeiro Skroski
25/12/21 Ã s 08:14

Sim Galera, percebi o mesmo problema, e me ajudaram! Obrigado!











08/12/21 Ã s 23:13
Problema testes desafio 1
Aula em: Primeiro projeto com Node.js â€º Primeiro projeto com Node.js â€º Remover conta

Boa Noite,

Acabei de fazer o desafio 1 e os testes nÃ£o estÃ£o passando apesar da aplicaÃ§Ã£o estar funcionando 100%. AlguÃ©m pode me dar uma luz ?

erro1.png

erro2.png

erro3.png

erro4.png

Segue o link do meu repositÃ³rio com o cÃ³digo atualizado:
https://github.com/colacobruno/node-desafio1
Melhor Resposta
Dalton Menezes
09/12/21 Ã s 08:48

Falaaaa @Bruno ColaÃ§o Moreira, tudo bem? ğŸ˜„

Na rota app.post('/users', Ã© esperado que se retorne o usuÃ¡rio que foi cadastrado, por isso o ideal Ã© separar o user em um objeto antes de fazer o push, para que, assim, possa reaproveitar esse objeto e mandar na resposta. No caso, ficaria assim:

const user = {
  name,
  username,
  id: uuidv4(),
  todos: []
}

users.push(user);

return response.status(201).json(user);

JÃ¡ na rota app.post('/todos', precisamos fazer o mesmo com o todo:

const todo = {
  id: uuidv4(),
  title,
  done: false,
  deadline: new Date(deadline),
  created_at: new Date()
}

user.todos.push(todo)

return response.status(201).json(todo);

Por fim, na rota de app.delete('/todos/:id', troque de findIndex para find, assim, no splice, ele removerÃ¡ baseado na referÃªncia desse objeto. Ficaria assim:

const todo = user.todos.find((todo) => todo.id === id)

if (!todo) {
  return response.status(404).json({
    error: "Tarefa nÃ£o encontrada"
  });
}

user.todos.splice(todo);

return response.status(204).json();

Essas alteraÃ§Ãµes deverÃ£o resolver o problema.
Tente ai e me diga se deu certinho, por favor. ğŸ’œğŸš€
Bruno ColaÃ§o Moreira
09/12/21 Ã s 09:23

Obrigado.
Agora os testes funcionaram, srrsrs

A propÃ³sito, como vc escreveu os cÃ³digos aqui ? eu li um tutorial de vocÃªs que era pra usar crase 3x e eu fiz isso mas nÃ£o ficou assim.

Vejo o povo colocando e ficando colorido assim e tal e nÃ£o achei essa opÃ§Ã£o.
Rocketseat
Dalton Menezes
09/12/21 Ã s 09:29

@Bruno ColaÃ§o Moreira de nada, fico muito feliz em ajudar. Sobre a formataÃ§Ã£o de cÃ³digo, usamos a sintaxe de markdown:
codehighlight.gif

Bons estudos ğŸ’œğŸš€
Bruno ColaÃ§o Moreira
10/12/21 Ã s 19:18

@Dalton Menezes ah...tinha esquecido do js , rsrsrsrsrs
Todas as respostas

PÃ¡gina 1 de pÃ¡gina 1
Bento Menni Domingos Pedro
05/04/22 Ã s 21:34 | Editado em 05/04/2022

@Dalton Menezes,

Eu estou tendo este erro durante o test pelo jest mas no insomnia estÃ¡ tudo funcionando. Fiz alteraÃ§Ã£o apenas ao post /todos conforme indicaste mas nÃ£o passa. Outros passaram de primeira.

image.png

image.png
Bento Menni Domingos Pedro
05/04/22 Ã s 22:00

resolvido cara
Dalton Menezes
09/12/21 Ã s 08:48

Falaaaa @Bruno ColaÃ§o Moreira, tudo bem? ğŸ˜„

Na rota app.post('/users', Ã© esperado que se retorne o usuÃ¡rio que foi cadastrado, por isso o ideal Ã© separar o user em um objeto antes de fazer o push, para que, assim, possa reaproveitar esse objeto e mandar na resposta. No caso, ficaria assim:

const user = {
  name,
  username,
  id: uuidv4(),
  todos: []
}

users.push(user);

return response.status(201).json(user);

JÃ¡ na rota app.post('/todos', precisamos fazer o mesmo com o todo:

const todo = {
  id: uuidv4(),
  title,
  done: false,
  deadline: new Date(deadline),
  created_at: new Date()
}

user.todos.push(todo)

return response.status(201).json(todo);

Por fim, na rota de app.delete('/todos/:id', troque de findIndex para find, assim, no splice, ele removerÃ¡ baseado na referÃªncia desse objeto. Ficaria assim:

const todo = user.todos.find((todo) => todo.id === id)

if (!todo) {
  return response.status(404).json({
    error: "Tarefa nÃ£o encontrada"
  });
}

user.todos.splice(todo);

return response.status(204).json();

Essas alteraÃ§Ãµes deverÃ£o resolver o problema.
Tente ai e me diga se deu certinho, por favor. ğŸ’œğŸš€
Bruno ColaÃ§o Moreira
09/12/21 Ã s 09:23

Obrigado.
Agora os testes funcionaram, srrsrs

A propÃ³sito, como vc escreveu os cÃ³digos aqui ? eu li um tutorial de vocÃªs que era pra usar crase 3x e eu fiz isso mas nÃ£o ficou assim.

Vejo o povo colocando e ficando colorido assim e tal e nÃ£o achei essa opÃ§Ã£o.
Rocketseat
Dalton Menezes
09/12/21 Ã s 09:29

@Bruno ColaÃ§o Moreira de nada, fico muito feliz em ajudar. Sobre a formataÃ§Ã£o de cÃ³digo, usamos a sintaxe de markdown:
codehighlight.gif

Bons estudos ğŸ’œğŸš€
Bruno ColaÃ§o Moreira
10/12/21 Ã s 19:18

@Dalton Menezes ah...tinha esquecido do js , rsrsrsrsrs













20/11/21 Ã s 18:53 | Editado em 18/01/2022
Splice
Aula em: Primeiro projeto com Node.js â€º Primeiro projeto com Node.js â€º Remover conta

Na documentaÃ§Ã£o do splice diz ele espera um Ã­ndice por onde comeÃ§ar a remover itens, a quantidade de itens a ser removida e o resto dos argumentos sÃ£o itens a serem inclusos na array. O que eu nÃ£o entendi Ã© como passar um objeto como primeiro argumento diz para o splice que ele tem que remover aquele objeto em especÃ­fico. Por de baixo dos panos o JavaScript roda um findIndex ou coisa parecida?
Melhor Resposta
Ricardo Passos
22/11/21 Ã s 19:39 | Editado em 01/12/2021

Opa, Elias.

Acredito que nÃ£o seja isso nÃ£o. Como eu fiquei com uma pulga atrÃ¡s da orelha, fiz alguns testes. Ao que parece, quando passamos um objeto como primeiro argumento para o splice, ele (o splice) acaba removendo SEMPRE o primeiro item do array. Fiz um pequeno script para testar:

<body>
    <div>
      <label for="name">Nome</label>
      <input id="name" type="text" />

      <label for="email">Email</label>
      <input id="email" type="text" />

      <button>Cadastrar</button>
      <button>Remover usuÃ¡rio</button>
    </div>

    <div>
      <h2>UsuÃ¡rios</h2>
      <pre></pre>
    </div>

    <script>
      // botÃµes
      const addUser = document.getElementsByTagName('button')[0]
      const removeUser = document.getElementsByTagName('button')[1]

      // inputs
      const nameInput = document.querySelector('#name')
      const emailInput = document.querySelector('#email')
      const preElem = document.querySelector('pre')

      const customers = []

      function addCustomer() {
        const name = nameInput.value
        const email = emailInput.value

        const user = {
          name,
          email,
        }

        customers.push(user)
        console.log(customers)
        preElem.innerText = JSON.stringify(customers, null, 2)
      }

      // segundo objeto dentro array
      // a ideia Ã© passar esse objeto para o splice e ver se o splice irÃ¡ remover
      // o segundo objeto
      const secondUserRef = customers[1]

      function removeCustomer() {
        console.log('before splice', customers)
        customers.splice(secondUserRef, 1)
        console.log('after splice', customers)
        
        preElem.innerText = JSON.stringify(customers, null, 2)
      }

      addUser.addEventListener('click', addCustomer)
      removeUser.addEventListener('click', removeCustomer)
    </script>
  </body>

Por favor, me corrija se eu estiver equivocado. Se quiser, pode fechar esse tÃ³pico, Ã© mais sÃ³ uma curiosidade mesmo.
Todas as respostas

PÃ¡gina 1 de pÃ¡gina 1
AndrÃ© Henrique Freitas do Amaral
01/12/21 Ã s 15:38 | Editado em 18/01/2022

@Ricardo Passos,

TambÃ©m fiquei muito confuso com esse uso do splice na rota da API.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

O primeiro argumento de splice Ã© o start, um argumento tipo number. Qualquer objeto que seja passado para start serÃ¡ considerado como 0, assim como boolean, undefined e null.

AtenÃ§ao especial para os nÃºmeros negativos: Se o parametro start for chamado com o valor -n, onde n Ã© um nÃºmero, o splice converterÃ¡ para array.length - n. Ou seja, -1 indica o Ãºltimo elemento, -2 o penÃºltimo, etc.

Se o splice estivesse sendo usado assim em TypeScript nao seria possÃ­vel compilar o cÃ³digo.

Att.,
Ricardo Passos
02/12/21 Ã s 09:03

AgradeÃ§o pelo complemento na resposta AndrÃ©
Ricardo Passos
22/11/21 Ã s 19:39 | Editado em 01/12/2021

Opa, Elias.

Acredito que nÃ£o seja isso nÃ£o. Como eu fiquei com uma pulga atrÃ¡s da orelha, fiz alguns testes. Ao que parece, quando passamos um objeto como primeiro argumento para o splice, ele (o splice) acaba removendo SEMPRE o primeiro item do array. Fiz um pequeno script para testar:

<body>
    <div>
      <label for="name">Nome</label>
      <input id="name" type="text" />

      <label for="email">Email</label>
      <input id="email" type="text" />

      <button>Cadastrar</button>
      <button>Remover usuÃ¡rio</button>
    </div>

    <div>
      <h2>UsuÃ¡rios</h2>
      <pre></pre>
    </div>

    <script>
      // botÃµes
      const addUser = document.getElementsByTagName('button')[0]
      const removeUser = document.getElementsByTagName('button')[1]

      // inputs
      const nameInput = document.querySelector('#name')
      const emailInput = document.querySelector('#email')
      const preElem = document.querySelector('pre')

      const customers = []

      function addCustomer() {
        const name = nameInput.value
        const email = emailInput.value

        const user = {
          name,
          email,
        }

        customers.push(user)
        console.log(customers)
        preElem.innerText = JSON.stringify(customers, null, 2)
      }

      // segundo objeto dentro array
      // a ideia Ã© passar esse objeto para o splice e ver se o splice irÃ¡ remover
      // o segundo objeto
      const secondUserRef = customers[1]

      function removeCustomer() {
        console.log('before splice', customers)
        customers.splice(secondUserRef, 1)
        console.log('after splice', customers)
        
        preElem.innerText = JSON.stringify(customers, null, 2)
      }

      addUser.addEventListener('click', addCustomer)
      removeUser.addEventListener('click', removeCustomer)
    </script>
  </body>

Por favor, me corrija se eu estiver equivocado. Se quiser, pode fechar esse tÃ³pico, Ã© mais sÃ³ uma curiosidade mesmo.
Elias Gabriel
22/11/21 Ã s 09:25 | Editado em 01/12/2021

Opa @Ricardo Passos, tudo bem?

Esse customer que estÃ¡ sendo passado para o splice, aponta diretamente para o endereÃ§o de memÃ³ria da posiÃ§Ã£o do array. Como assim?

O customer foi criado no middleware verifyIfExistisAccountCPF, por meio da funÃ§Ã£o customers.find. Esse mÃ©todo find retorna diretamente o endereÃ§o de memÃ³ria dessa posiÃ§Ã£o.

Quando passa esse "endereÃ§o" para o splice, ele sabe exatamente a partir de onde remover. EntÃ£o nÃ£o, nÃ£o Ã© feito um findIndex por baixo dos panos, pois o JavaScript nÃ£o sabe com que condiÃ§Ã£o se basear na comparaÃ§Ã£o.

Espero ter ajudado, abraÃ§os ğŸ’œ
AndrÃ© Henrique Freitas do Amaral
01/12/21 Ã s 15:33

Oi @Elias Gabriel,

Creio que hÃ¡ um equÃ­voco. O mÃ©todo splice nao sabe a partir do "endereÃ§o" qual elemento do array precisa ser removido. Assim como @Ricardo Passos quis demonstrar.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

O primeiro argumento de splice Ã© o start, um argumento tipo number. Qualquer objeto que seja passado para start serÃ¡ considerado como 0, assim como boolean, undefined e null.

Se o cÃ³digo estivesse sendo escrito em TypeScript nao seria possÃ­vel compilar.

Att.,

















10/12/21 Ã s 20:46 | Editado em 11/12/2021
Por que no delete e em outros verbos estÃ¡ pegando o customer pelo request e nÃ£o pelo header?
Aula em: Primeiro projeto com Node.js â€º Primeiro projeto com Node.js â€º Remover conta

No caso, como o insomia sabe que o customer vem do head?

app.post("/account", (request, response) => {

    const { cpf, name } = request.body;
    const customersAlreadyExists = customers.some(customer => customer.cpf === cpf);

    if (customersAlreadyExists) {
        return response.status(400).json({ error: "Customer already exists" });
    }


    customers.push({
        cpf,
        name,
        id: uuidv4(),
        statement: []
    });

    return response.status(201).send();
})

app.put("/account", verifyIfExistsAccountCPF, (request, response) => {
    const { name } = request.body;
    const { customer } = request;
    customer.name = name;

    return response.status(201).send();
})

app.delete("/account", verifyIfExistsAccountCPF, (request, response) => {
    const { customer } = request;

    customers.splice(customer, 1);

    return response.status(200).send(customers);

})

app.get("/account", verifyIfExistsAccountCPF, (request, response) => {
    const { customer } = request;
    return response.json(customer);
})

app.get("/statement", verifyIfExistsAccountCPF, (request, response) => {

    const { customer } = request;
    return response.json(customer.statement);

})


app.post("/deposit", verifyIfExistsAccountCPF, (request, response) => {

    const { description, amount } = request.body;
    const { customer } = request;
    const statementOperation = {
        description,
        amount,
        created_at: new Date(),
        type: "credit"

    }

    customer.statement.push(statementOperation);
    return response.status(201).send();

})

app.post('/withdraw', verifyIfExistsAccountCPF, (request, response) => {

    const { amount } = request.body;
    const { customer } = request;

    const balance = getBalance(customer.statement);

    if (balance < amount) {
        return response.status(400).json({ error: "Insuficient funds" })
    }

    const statementOperation = {
        amount,
        created_at: new Date(),
        type: "debit"

    }

    customer.statement.push(statementOperation);
    return response.status(201).send();

});

Melhor Resposta
Elias Gabriel
11/12/21 Ã s 12:18

Opa @Gustavo Goulart, tudo bem?

Na verdade o Insomnia nÃ£o tem conhecimento sobre essa configuraÃ§Ã£o da API, sÃ£o coisas diferentes.

Mas respondendo a pergunta do tÃ­tulo do tÃ³pico, Ã© possÃ­vel receber o costumer por dentro da request pois no middleware verifyIfExistsAccountCPF adicionamos essa propriedade caso passe na validaÃ§Ã£o.

Por isso Ã© possÃ­vel recuperar essa propriedade em rotas que utilizam essa middleware.

No mais, espero ter ajudado de alguma forma! Qualquer coisa Ã© sÃ³ falar.

AbraÃ§os ğŸ’œ
Todas as respostas

PÃ¡gina 1 de pÃ¡gina 1
Gustavo Goulart
11/12/21 Ã s 19:37

Entendi, obrigado!!
Elias Gabriel
11/12/21 Ã s 12:18

Opa @Gustavo Goulart, tudo bem?

Na verdade o Insomnia nÃ£o tem conhecimento sobre essa configuraÃ§Ã£o da API, sÃ£o coisas diferentes.

Mas respondendo a pergunta do tÃ­tulo do tÃ³pico, Ã© possÃ­vel receber o costumer por dentro da request pois no middleware verifyIfExistsAccountCPF adicionamos essa propriedade caso passe na validaÃ§Ã£o.

Por isso Ã© possÃ­vel recuperar essa propriedade em rotas que utilizam essa middleware.

No mais, espero ter ajudado de alguma forma! Qualquer coisa Ã© sÃ³ falar.

AbraÃ§os ğŸ’œ











